<template>
  <div class="chart-container">
    <canvas ref="chartCanvas"></canvas>
  </div>
</template>

<script>
import { Chart, registerables } from 'chart.js'

Chart.register(...registerables)

export default {
  name: 'ROIBarChart',
  props: {
    bets: {
      type: Array,
      required: true
    }
  },
  data() {
    return {
      chart: null
    }
  },
  watch: {
    bets: {
      handler: 'updateChart',
      deep: true,
      immediate: true
    }
  },
  mounted() {
    this.$nextTick(() => {
      this.createChart()
      this.forceChartBackground()
      this.forceChartColors()
      
      // Observar mudanÃ§as de tema
      this.observeThemeChanges()
    })
  },
  beforeUnmount() {
    if (this.chart) {
      this.chart.destroy()
    }
    
    // Limpar observer de tema
    if (this.themeObserver) {
      this.themeObserver.disconnect()
    }
    
    // Limpar intervalo de verificaÃ§Ã£o
    if (this.backgroundCheckInterval) {
      clearInterval(this.backgroundCheckInterval)
    }
  },
  methods: {
    // MÃ©todo para obter cor do tema atual
    getThemeColor(cssVariable, fallback) {
      try {
        const value = getComputedStyle(document.documentElement).getPropertyValue(cssVariable)
        return value || fallback
      } catch (error) {
        return fallback
      }
    },
    
    // MÃ©todo para forÃ§ar o fundo do grÃ¡fico
    forceChartBackground() {
      if (!this.chart) return
      
      const canvas = this.chart.canvas
      
      // Aplicar fundo via CSS inline com !important
      canvas.style.setProperty('background-color', this.getThemeColor('--bg-tertiary', '#2d2d2d'), 'important')
      canvas.style.setProperty('background', this.getThemeColor('--bg-tertiary', '#2d2d2d'), 'important')
      
      // ForÃ§ar redraw do grÃ¡fico
      this.chart.update('none')
      
      // Aplicar fundo diretamente no contexto 2D apÃ³s um delay
      setTimeout(() => {
        if (this.chart && this.chart.ctx) {
          const chartCtx = this.chart.ctx
          const chartArea = this.chart.chartArea
          
          if (chartArea) {
            chartCtx.save()
            chartCtx.globalCompositeOperation = 'destination-over'
            chartCtx.fillStyle = this.getThemeColor('--bg-tertiary', '#2d2d2d')
            chartCtx.fillRect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top)
            chartCtx.restore()
          }
        }
      }, 200)
    },
    
    // MÃ©todo para forÃ§ar atualizaÃ§Ã£o das cores
    forceChartColors() {
      if (!this.chart) return
      
      // Atualizar cores dos eixos
      this.chart.options.scales.x.grid.color = this.getThemeColor('--border-primary', '#404040')
      this.chart.options.scales.x.ticks.color = this.getThemeColor('--text-primary', '#ffffff')
      this.chart.options.scales.y.grid.color = this.getThemeColor('--border-primary', '#404040')
      this.chart.options.scales.y.ticks.color = this.getThemeColor('--text-primary', '#ffffff')
      
      // Atualizar cores dos tooltips
      this.chart.options.plugins.tooltip.backgroundColor = this.getThemeColor('--accent-primary', '#00ff88')
      this.chart.options.plugins.tooltip.titleColor = this.getThemeColor('--text-primary', '#ffffff')
      this.chart.options.plugins.tooltip.bodyColor = this.getThemeColor('--text-primary', '#ffffff')
      this.chart.options.plugins.tooltip.borderColor = this.getThemeColor('--accent-secondary', '#00cc6a')
      
      // ForÃ§ar redraw
      this.chart.update('none')
    },
    
    // Observar mudanÃ§as de tema
    observeThemeChanges() {
      if (typeof MutationObserver !== 'undefined') {
        const observer = new MutationObserver((mutations) => {
          mutations.forEach((mutation) => {
            if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
              console.log('ðŸŽ¨ Tema mudou detectado! Aplicando novas cores...')
              // Aguardar um pouco para o tema ser aplicado
              setTimeout(() => {
                this.forceChartBackground()
                this.forceChartColors()
              }, 100)
            }
          })
        })
        
        // Observar mudanÃ§as no atributo data-theme do html
        observer.observe(document.documentElement, {
          attributes: true,
          attributeFilter: ['data-theme']
        })
        
        // Guardar referÃªncia para limpeza
        this.themeObserver = observer
      }
      
      // Verificar fundo e cores periodicamente
      this.backgroundCheckInterval = setInterval(() => {
        if (this.chart) {
          this.forceChartBackground()
          this.forceChartColors()
        }
      }, 2000) // Verificar a cada 2 segundos
      
      // Verificar tema atual e aplicar cores
      this.checkAndApplyTheme()
    },
    
    // Verificar e aplicar tema atual
    checkAndApplyTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark'
      console.log(`ðŸŽ¯ Tema atual detectado: ${currentTheme}`)
      
      // Aplicar cores baseadas no tema atual
      setTimeout(() => {
        this.forceChartColors()
      }, 500)
    },
    
    // MÃ©todo pÃºblico para forÃ§ar atualizaÃ§Ã£o de tema
    forceThemeUpdate() {
      console.log('ðŸ”„ ForÃ§ando atualizaÃ§Ã£o de tema...')
      this.forceChartBackground()
      this.forceChartColors()
    },
    
    createChart() {
      const ctx = this.$refs.chartCanvas
      if (!ctx) return
      
      this.chart = new Chart(ctx, {
        type: 'bar',
        data: this.getChartData(),
        options: {
          responsive: true,
          maintainAspectRatio: false,
          indexAxis: 'y',
          // ConfiguraÃ§Ã£o do fundo do grÃ¡fico
          backgroundColor: this.getThemeColor('--bg-tertiary', '#2d2d2d'),
          plugins: {
            // Plugin personalizado para fundo do canvas
            customCanvasBackgroundColor: {
              id: 'customCanvasBackgroundColor',
              beforeDraw: (chart) => {
                const ctx = chart.ctx;
                const chartArea = chart.chartArea;
                
                // ForÃ§ar fundo da Ã¡rea de plotagem
                if (chartArea) {
                  ctx.save();
                  ctx.globalCompositeOperation = 'destination-over';
                  ctx.fillStyle = this.getThemeColor('--bg-tertiary', '#2d2d2d');
                  ctx.fillRect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                  ctx.restore();
                }
              }
            },
            legend: {
              display: false
            },
            tooltip: {
              backgroundColor: this.getThemeColor('--accent-primary', '#00ff88'),
              titleColor: this.getThemeColor('--text-primary', '#ffffff'),
              bodyColor: this.getThemeColor('--text-primary', '#ffffff'),
              borderColor: this.getThemeColor('--accent-secondary', '#00cc6a'),
              borderWidth: 1,
              callbacks: {
                title: (context) => {
                  return context[0].label
                },
                label: (context) => {
                  return `ROI: ${context.parsed.x.toFixed(2)}%`
                }
              }
            }
          },
          scales: {
            x: {
              grid: {
                color: this.getThemeColor('--border-primary', '#404040')
              },
              ticks: {
                color: this.getThemeColor('--text-primary', '#ffffff'),
                callback: (value) => {
                  return `${value.toFixed(1)}%`
                }
              }
            },
            y: {
              grid: {
                color: this.getThemeColor('--border-primary', '#404040')
              },
              ticks: {
                color: this.getThemeColor('--text-primary', '#ffffff'),
                maxTicksLimit: 10
              }
            }
          },
          elements: {
            bar: {
              backgroundColor: (context) => {
                const value = context.parsed.x
                if (value >= 0) {
                  return this.getThemeColor('--accent-primary', '#00ff88')
                } else {
                  return this.getThemeColor('--error-color', '#ff4444')
                }
              },
              borderColor: (context) => {
                const value = context.parsed.x
                if (value >= 0) {
                  return this.getThemeColor('--accent-secondary', '#00cc6a')
                } else {
                  return this.getThemeColor('--error-hover', '#ff6666')
                }
              },
              borderWidth: 1
            }
          }
        }
      })
    },
    
    getChartData() {
      if (!this.bets || this.bets.length === 0) {
        return {
          labels: ['Sem dados'],
          datasets: [{
            data: [0],
            label: 'ROI por Aposta'
          }]
        }
      }

      // Pega as Ãºltimas 10 apostas para o grÃ¡fico
      const recentBets = [...this.bets]
        .sort((a, b) => new Date(b.date) - new Date(a.date))
        .slice(0, 10)
        .reverse()
      
      const labels = recentBets.map(bet => {
        const matchName = bet.match && bet.match.length > 20 
          ? bet.match.substring(0, 20) + '...' 
          : bet.match || 'Partida'
        return `${matchName} (${bet.sport || 'Esporte'})`
      })
      
      const data = recentBets.map(bet => bet.roi || 0)
      
      return {
        labels,
        datasets: [{
          data,
          label: 'ROI por Aposta'
        }]
      }
    },
    
    updateChart() {
      if (this.chart) {
        this.chart.data = this.getChartData()
        this.chart.update('active')
        
        // ForÃ§ar fundo apÃ³s atualizaÃ§Ã£o
        setTimeout(() => {
          this.forceChartBackground()
        }, 100)
      } else {
        this.$nextTick(() => {
          this.createChart()
        })
      }
    }
  }
}
</script>

<style scoped>
.chart-container {
  height: 100%;
  width: 100%;
  position: relative;
  min-height: 200px;
  max-height: 100%;
  overflow: hidden;
}

canvas {
  max-width: 100%;
  max-height: 100%;
}

/* ForÃ§ar fundo do grÃ¡fico via CSS */
.chart-container canvas {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Estilos especÃ­ficos para modo dark */
[data-theme="dark"] .chart-container canvas {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Estilos especÃ­ficos para modo light */
[data-theme="light"] .chart-container canvas {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* ForÃ§ar fundo tambÃ©m no container */
.chart-container {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Estilos especÃ­ficos para modo dark no container */
[data-theme="dark"] .chart-container {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Estilos especÃ­ficos para modo light no container */
[data-theme="light"] .chart-container {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* Regras adicionais para forÃ§ar o fundo */
.chart-container canvas[style*="background"] {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}

/* ForÃ§ar fundo em todos os elementos do grÃ¡fico */
.chart-container * {
  background-color: var(--bg-tertiary) !important;
}

/* Regra especÃ­fica para o canvas do Chart.js */
.chart-container canvas[width][height] {
  background-color: var(--bg-tertiary) !important;
  background: var(--bg-tertiary) !important;
}
</style>
