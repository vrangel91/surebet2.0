/**
 * Teste de Carga Realista para SurebetsView
 * Simula acessos distribu√≠dos ao longo do tempo (como na pr√°tica)
 */

const axios = require('axios');
const { performance } = require('perf_hooks');

class RealisticLoadTester {
  constructor() {
    this.baseURL = 'http://localhost:3001';
    this.totalUsers = 50; // 50 usu√°rios ao longo de 5 minutos
    this.testDuration = 300000; // 5 minutos
    this.results = [];
    this.errors = [];
    this.startTime = null;
    this.isRunning = false;
  }

  /**
   * Simula um usu√°rio real acessando a p√°gina
   */
  async simulateRealUser(userId) {
    const userResults = {
      userId,
      requests: [],
      errors: [],
      startTime: Date.now(),
      sessionDuration: 0
    };

    try {
      // 1. Usu√°rio acessa a p√°gina (primeira requisi√ß√£o)
      const pageStart = performance.now();
      const pageResponse = await axios.get(`${this.baseURL}/api/surebets`, {
        timeout: 10000,
        headers: {
          'User-Agent': `RealUser-${userId}/1.0`
        }
      });
      const pageTime = performance.now() - pageStart;
      
      userResults.requests.push({
        type: 'initial_load',
        duration: pageTime,
        status: pageResponse.status,
        timestamp: Date.now()
      });

      // 2. Usu√°rio fica na p√°gina por um tempo (simular navega√ß√£o)
      const sessionTime = Math.random() * 30000 + 10000; // 10-40 segundos
      await new Promise(resolve => setTimeout(resolve, sessionTime));

      // 3. Usu√°rio faz algumas requisi√ß√µes durante a sess√£o (2-5 requisi√ß√µes)
      const requestCount = Math.floor(Math.random() * 4) + 2; // 2-5 requisi√ß√µes
      
      for (let i = 0; i < requestCount && this.isRunning; i++) {
        const requestStart = performance.now();
        
        try {
          const response = await axios.get(`${this.baseURL}/api/surebets`, {
            timeout: 5000,
            headers: {
              'User-Agent': `RealUser-${userId}/1.0`
            }
          });

          const requestTime = performance.now() - requestStart;
          
          userResults.requests.push({
            type: 'navigation',
            duration: requestTime,
            status: response.status,
            requestNumber: i + 1,
            timestamp: Date.now()
          });

          // Pausa entre requisi√ß√µes (1-5 segundos)
          const pauseTime = Math.random() * 4000 + 1000;
          await new Promise(resolve => setTimeout(resolve, pauseTime));

        } catch (error) {
          const requestTime = performance.now() - requestStart;
          userResults.errors.push({
            type: 'navigation_error',
            error: error.message,
            duration: requestTime,
            requestNumber: i + 1,
            timestamp: Date.now()
          });
        }
      }

      userResults.endTime = Date.now();
      userResults.sessionDuration = userResults.endTime - userResults.startTime;
      userResults.success = userResults.errors.length < (userResults.requests.length * 0.2); // 80% de sucesso

    } catch (error) {
      userResults.errors.push({
        type: 'fatal',
        message: error.message,
        timestamp: Date.now()
      });
      userResults.success = false;
      userResults.endTime = Date.now();
      userResults.sessionDuration = userResults.endTime - userResults.startTime;
    }

    return userResults;
  }

  /**
   * Executa teste realista com usu√°rios distribu√≠dos
   */
  async runRealisticTest() {
    console.log('üåç Iniciando Teste de Carga Realista - SurebetsView');
    console.log('='.repeat(60));
    console.log(`üë• Total de usu√°rios: ${this.totalUsers}`);
    console.log(`‚è±Ô∏è Dura√ß√£o do teste: ${this.testDuration / 1000} segundos (${this.testDuration / 60000} minutos)`);
    console.log(`üìä Usu√°rios distribu√≠dos ao longo do tempo`);
    console.log('');

    this.startTime = Date.now();
    this.isRunning = true;

    // Distribuir usu√°rios ao longo do tempo
    const promises = [];
    const userInterval = this.testDuration / this.totalUsers; // Intervalo entre usu√°rios

    for (let i = 0; i < this.totalUsers; i++) {
      const delay = i * userInterval;
      
      // Agendar usu√°rio para entrar ap√≥s o delay
      const userPromise = new Promise(resolve => {
        setTimeout(async () => {
          if (this.isRunning) {
            console.log(`üë§ Usu√°rio ${i + 1}/${this.totalUsers} entrando...`);
            const result = await this.simulateRealUser(i + 1);
            resolve(result);
          } else {
            resolve(null);
          }
        }, delay);
      });
      
      promises.push(userPromise);
    }

    // Timer para parar o teste ap√≥s a dura√ß√£o especificada
    const timer = setTimeout(() => {
      this.isRunning = false;
      console.log('\n‚è∞ Tempo limite atingido, finalizando teste...');
    }, this.testDuration);

    // Aguardar todos os usu√°rios terminarem
    const results = await Promise.allSettled(promises);
    clearTimeout(timer);
    this.isRunning = false;

    // Processar resultados
    results.forEach((result, index) => {
      if (result.status === 'fulfilled' && result.value) {
        this.results.push(result.value);
      } else if (result.status === 'rejected') {
        this.errors.push({
          userId: index + 1,
          error: result.reason.message
        });
      }
    });

    const endTime = Date.now();
    const totalDuration = endTime - this.startTime;

    console.log(`\n‚úÖ Teste realista conclu√≠do em ${totalDuration}ms`);
    this.generateRealisticReport(totalDuration);
  }

  /**
   * Gera relat√≥rio detalhado do teste realista
   */
  generateRealisticReport(totalDuration) {
    console.log('\nüåç RELAT√ìRIO DE TESTE REALISTA');
    console.log('='.repeat(60));

    const successfulUsers = this.results.filter(r => r.success).length;
    const failedUsers = this.results.filter(r => !r.success).length;
    const totalUsers = this.results.length + this.errors.length;

    console.log(`üë• Usu√°rios totais: ${totalUsers}`);
    console.log(`‚úÖ Usu√°rios bem-sucedidos: ${successfulUsers}`);
    console.log(`‚ùå Usu√°rios com falha: ${failedUsers}`);
    console.log(`üìà Taxa de sucesso: ${((successfulUsers / totalUsers) * 100).toFixed(2)}%`);

    // Estat√≠sticas de sess√£o
    const allRequests = this.results.flatMap(r => r.requests);
    const allErrors = this.results.flatMap(r => r.errors);
    const totalRequests = allRequests.length + allErrors.length;
    const successfulRequests = allRequests.length;
    const failedRequests = allErrors.length;

    console.log('\nüìä ESTAT√çSTICAS DE SESS√ÉO');
    console.log('-'.repeat(40));
    console.log(`üì§ Total de requisi√ß√µes: ${totalRequests}`);
    console.log(`‚úÖ Requisi√ß√µes bem-sucedidas: ${successfulRequests}`);
    console.log(`‚ùå Requisi√ß√µes com falha: ${failedRequests}`);
    console.log(`üìà Taxa de sucesso de requisi√ß√µes: ${((successfulRequests / totalRequests) * 100).toFixed(2)}%`);

    if (allRequests.length > 0) {
      const durations = allRequests.map(r => r.duration);
      const initialLoads = allRequests.filter(r => r.type === 'initial_load');
      const navigations = allRequests.filter(r => r.type === 'navigation');
      
      console.log('\n‚è±Ô∏è PERFORMANCE DAS REQUISI√á√ïES');
      console.log('-'.repeat(40));
      console.log(`‚ö° Tempo m√©dio geral: ${(durations.reduce((a, b) => a + b, 0) / durations.length).toFixed(2)}ms`);
      console.log(`üöÄ Tempo m√≠nimo: ${Math.min(...durations).toFixed(2)}ms`);
      console.log(`üêå Tempo m√°ximo: ${Math.max(...durations).toFixed(2)}ms`);

      if (initialLoads.length > 0) {
        const initialTimes = initialLoads.map(r => r.duration);
        console.log(`\nüìÑ Carregamento inicial:`);
        console.log(`   M√©dia: ${(initialTimes.reduce((a, b) => a + b, 0) / initialTimes.length).toFixed(2)}ms`);
        console.log(`   M√≠nimo: ${Math.min(...initialTimes).toFixed(2)}ms`);
        console.log(`   M√°ximo: ${Math.max(...initialTimes).toFixed(2)}ms`);
      }

      if (navigations.length > 0) {
        const navTimes = navigations.map(r => r.duration);
        console.log(`\nüß≠ Navega√ß√£o:`);
        console.log(`   M√©dia: ${(navTimes.reduce((a, b) => a + b, 0) / navTimes.length).toFixed(2)}ms`);
        console.log(`   M√≠nimo: ${Math.min(...navTimes).toFixed(2)}ms`);
        console.log(`   M√°ximo: ${Math.max(...navTimes).toFixed(2)}ms`);
      }

      // An√°lise de percentis
      const sortedDurations = durations.sort((a, b) => a - b);
      const p50 = sortedDurations[Math.floor(sortedDurations.length * 0.5)];
      const p90 = sortedDurations[Math.floor(sortedDurations.length * 0.9)];
      const p95 = sortedDurations[Math.floor(sortedDurations.length * 0.95)];

      console.log(`\nüìà Percentis de Performance:`);
      console.log(`   P50 (mediana): ${p50.toFixed(2)}ms`);
      console.log(`   P90: ${p90.toFixed(2)}ms`);
      console.log(`   P95: ${p95.toFixed(2)}ms`);
    }

    // Estat√≠sticas de sess√£o
    const sessionDurations = this.results.map(r => r.sessionDuration);
    const avgSessionDuration = sessionDurations.length > 0 
      ? sessionDurations.reduce((a, b) => a + b, 0) / sessionDurations.length 
      : 0;

    console.log('\nüë§ ESTAT√çSTICAS DE SESS√ÉO');
    console.log('-'.repeat(40));
    console.log(`‚è±Ô∏è Dura√ß√£o m√©dia de sess√£o: ${(avgSessionDuration / 1000).toFixed(2)}s`);
    console.log(`üìä Requisi√ß√µes por usu√°rio: ${(totalRequests / totalUsers).toFixed(1)}`);

    // Estat√≠sticas de throughput
    const requestsPerSecond = (totalRequests / (totalDuration / 1000)).toFixed(2);
    const usersPerMinute = (totalUsers / (totalDuration / 60000)).toFixed(2);

    console.log('\nüöÄ THROUGHPUT');
    console.log('-'.repeat(40));
    console.log(`‚ö° Requisi√ß√µes/segundo: ${requestsPerSecond}`);
    console.log(`üë• Usu√°rios/minuto: ${usersPerMinute}`);

    // An√°lise de erros
    if (allErrors.length > 0) {
      console.log('\n‚ùå AN√ÅLISE DE ERROS');
      console.log('-'.repeat(40));
      const errorTypes = {};
      allErrors.forEach(error => {
        const type = error.error || error.message || 'unknown';
        errorTypes[type] = (errorTypes[type] || 0) + 1;
      });
      
      Object.entries(errorTypes).forEach(([type, count]) => {
        console.log(`   ${type}: ${count} ocorr√™ncias`);
      });
    }

    // Avalia√ß√£o realista
    console.log('\nüéØ AVALIA√á√ÉO REALISTA');
    console.log('-'.repeat(40));

    let performanceScore = 100;
    let issues = [];

    // Avaliar taxa de sucesso
    const successRate = (successfulRequests / totalRequests) * 100;
    if (successRate < 95) {
      performanceScore -= 20;
      issues.push('Taxa de sucesso baixa (<95%)');
    } else if (successRate < 98) {
      performanceScore -= 10;
      issues.push('Taxa de sucesso moderada (<98%)');
    }

    // Avaliar tempo de resposta
    if (allRequests.length > 0) {
      const avgResponseTime = allRequests.reduce((sum, r) => sum + r.duration, 0) / allRequests.length;
      if (avgResponseTime > 500) {
        performanceScore -= 15;
        issues.push('Tempo de resposta alto (>500ms)');
      } else if (avgResponseTime > 200) {
        performanceScore -= 5;
        issues.push('Tempo de resposta moderado (>200ms)');
      }
    }

    // Avaliar throughput realista
    if (requestsPerSecond < 5) {
      performanceScore -= 10;
      issues.push('Throughput baixo para uso real (<5 req/s)');
    }

    console.log(`üìä Pontua√ß√£o de Performance: ${Math.max(0, performanceScore)}/100`);

    if (issues.length === 0) {
      console.log('‚úÖ EXCELENTE: Sistema suporta uso real sem problemas');
    } else {
      console.log('‚ö†Ô∏è PROBLEMAS DETECTADOS:');
      issues.forEach(issue => console.log(`   - ${issue}`));
    }

    // Recomenda√ß√µes realistas
    console.log('\nüí° RECOMENDA√á√ïES REALISTAS');
    console.log('-'.repeat(40));
    
    if (successRate < 98) {
      console.log('üîß Melhorar confiabilidade da API');
      console.log('üîß Implementar retry autom√°tico');
    }
    if (allRequests.length > 0 && allRequests.reduce((sum, r) => sum + r.duration, 0) / allRequests.length > 200) {
      console.log('üîß Otimizar tempo de resposta');
      console.log('üîß Verificar efici√™ncia do cache');
    }
    if (requestsPerSecond < 10) {
      console.log('üîß Sistema est√° bem dimensionado para uso real');
    }

    return {
      totalUsers,
      successfulUsers,
      failedUsers,
      totalRequests,
      successfulRequests,
      failedRequests,
      successRate,
      avgResponseTime: allRequests.length > 0 ? allRequests.reduce((sum, r) => sum + r.duration, 0) / allRequests.length : 0,
      requestsPerSecond,
      performanceScore,
      issues
    };
  }
}

// Executar teste se chamado diretamente
if (require.main === module) {
  const tester = new RealisticLoadTester();
  tester.runRealisticTest().catch(console.error);
}

module.exports = { RealisticLoadTester };
